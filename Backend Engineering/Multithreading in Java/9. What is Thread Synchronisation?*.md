
In multithreaded programming, a critical section is a part of the code that accesses shared resources (like variables, files, or data structures). If multiple threads enter the critical section simultaneously without proper control, it can lead to data inconsistency or corruption.

**Synchronisation** refers to a mechanism that ensures that only one thread at a time can execute the critical section, while other threads wait their turn.

---
## Synchronisation Mechanisms in Java

Java offers two ways to prevent multiple threads from accessing the same code at the same time:

1. **`synchronized` keyword** – An older, simpler approach that automatically locks the code block and manages thread waiting using a built-in condition (monitor).

2. `condition`: 

3. **`ReentrantLock` (JDK 5+)** – A newer and more flexible option that allows manual locking, timed waits, and multiple condition variables.

> **NOTE:** Learning `ReentrantLock` first can make it easier to understand how locking and thread coordination work, since it separates those concerns clearly.

---
### `ReentrantLock`

The basic outline for protecting a code block with a ReentrantLock is:

```
myLock.lock(); // a ReentrantLock object
try {
	critical section
}
finally {
	myLock.unlock();
}
```

As soon as one thread locks the lock object, no other thread can get past the lock statement. When other threads call lock, they are blocked until the first thread unlocks the lock object.

**Example**

```
public class Bank {

	private Lock bankLock = new ReentrantLock();

	public void transfer(int from, int to, int amount) {
		bankLock.lock();
		try {
			if (accounts[from] < amount) return;
			System.out.print(Thread.currentThread());
			accounts[from] -= amount;
			System.out.printf(" %10.2f from %d to %d", amount, from, to);
			accounts[to] += amount;
			System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
		}
		finally {
			bankLock.unlock();
		}
	}
	
}
```

> **NOTE:** Each `Bank` object has its own `ReentrantLock` object. If two threads try to access the same `Bank` object, then the lock serves to serialise the access. However, if two threads access different `Bank` objects, then each thread acquires a different lock and neither thread is blocked. This is as it should be, because the threads cannot interfere with another when they manipulate different `Bank` instances.

---
### `condition` Object

---

### `synchronized` Keyword


    
This keyword is fundamental for achieving synchronization in Java. It can be applied to methods or blocks of code.
    
- **Synchronized Methods:** When a method is declared as `synchronized`, only one thread can execute it at a time. Other threads trying to access the same method will be blocked until the current thread releases the lock.
    - **Synchronized Blocks:** This allows you to synchronize a specific block of code within a method. It uses a monitor or intrinsic lock associated with an object. Only one thread can execute the synchronized block for the same object at a time.
    
- **Monitors (Intrinsic Locks):**
    
    Every object in Java has an associated monitor. When a thread enters a `synchronized` method or block, it acquires the lock associated with the object.Other threads trying to access the same synchronized method or block for the same object will be blocked until the lock is released.
    
- `wait()`, `notify()`, and `notifyAll()` Methods:
    
    These methods are part of the `Object` class and are used for inter-thread communication.
    
    - `wait()`: Causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` on the same object. 
    - `notify()`: Wakes up a single thread that is waiting on the object's monitor. 
    - `notifyAll()`: Wakes up all threads that are waiting on the object's monitor. 
    
- **Locks:**
    
    The `java.util.concurrent.locks` package provides more flexible locking mechanisms, such as `ReentrantLock`, `ReadWriteLock`, and `StampedLock`.These locks offer more control and features compared to the basic `synchronized`keyword.
    
    - `ReentrantLock`: A more flexible lock that supports features like fairness and interruptibility.
    - `ReadWriteLock`: Allows multiple threads to read concurrently but only one thread to write at a time.
    - `StampedLock`: Provides a flexible way to control access to a shared resource, allowing multiple threads to read concurrently while also supporting exclusive write access.


---



public synchronized void method()

{

_method body_

}

is the equivalent of

public void method()

{

_implicitLock_.lock();

try

{

_method body_

}

---
### Synchronised Keyword

Method

```
public synchronized void deposit(int amount) {
    balance += amount;
}
```

- Locks on the **current object (`this`)**.
- Only one thread at a time can execute _any_ synchronized method on that object.

Synchronised Block

```
public void deposit(int amount) {
    synchronized(this) {
        balance += amount;
    }
}
```

- More **fine-grained control** — only synchronizes the critical section.
    
- Improves performance by reducing the scope of locking.

---
### Static Synchronisation

```
public static synchronized void log(String msg) {
    // ...
}
```

- Locks on the **class object (`ClassName.class`)**, not an instance.
    
- Used when shared data is **static**.

---
### How Synchronisation works?


---

Q. Threads wait for locks in a **blocked state**.

---

**Q. What will be the output of the following code snippet?**

```
class Demo {

    public static synchronized void syncStatic() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

    public synchronized void syncInstance() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        Thread t1 = new Thread(() -> d1.syncStatic(), "A");
        Thread t2 = new Thread(() -> d2.syncInstance(), "B");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Task implements Runnable {

    public synchronized void run() {
        System.out.print(Thread.currentThread().getName() + " ");
        try { Thread.sleep(50); } catch (InterruptedException e) {}
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Task t = new Task();
        Thread t1 = new Thread(t, "1");
        Thread t2 = new Thread(t, "2");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Printer {

    public void print() {
        synchronized(this) {
            System.out.print(Thread.currentThread().getName() + " ");
        }
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Printer p1 = new Printer();
        Printer p2 = new Printer();
        Thread t1 = new Thread(() -> p1.print(), "X");
        Thread t2 = new Thread(() -> p2.print(), "Y");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class MyClass {

    public synchronized static void staticMethod() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

}

public class Test {

    public static void main(String[] args) {
        Runnable r = MyClass::staticMethod;
        Thread t1 = new Thread(r, "A");
        Thread t2 = new Thread(r, "B");
        t1.start(); t2.start();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Counter {

    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -> { 
	        for (int i = 0; i < 1000; i++) counter.increment(); 
		});

        Thread t2 = new Thread(() -> { 
	        for (int i = 0; i < 1000; i++) counter.increment(); 
		});

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println(counter.getCount());

    }

}
```

---
