
Usually very hard to find bugs.
2. Higher cost of code maintenance since the code inherently becomes harder to reason about.
3. Increased utilization of system resources. Creation of each thread consumes additional memory, CPU cycles for book-keeping and waste of time in context switches.
4. Programs may experience slowdown as coordination amongst threads comes at a price.
5. Acquiring and releasing locks adds to program execution time. Threads fighting over acquiring locks cause lock contention.


With multithreading, multiple threads of a program can be executing different sections of the program code. However, caution should be exercised when threads of the same program attempt to execute the same portion of code.

Concurrency issues lead to race condition. Race conditions lead to data corruption.

**It all comes down to one potentially deadly scenario: _"two or more threads have access to a single object's data"_. In other words, methods executing on two different stacks are both calling, say, getters or setters on a single object on the heap.**

> **NOTE:** When a thread is not running, and in runnable (or blocked) it's essentially knocked unconscious. When it becomes the currently-running thread again, it doesn't know that it ever stopped.

Use the `synchronized` keyword to modify a method so that only one thread at a time can access it.

> **NOTE:** We can use the synchronized keyword to synchronize at the more fin-grained level of one or more statements, rather than at the whole-method level.

