
In multithreaded programming, a critical section is a part of the code that accesses shared resources (like variables, files, or data structures). If multiple threads enter the critical section simultaneously without proper control, it can lead to data inconsistency or corruption.

**Synchronisation** mechanisms such as locks, semaphores, and the `synchronized` keyword (in languages like Java) ensure that only one thread at a time can execute the critical section, while other threads wait their turn.

---


---
## Synchronisation Mechanisms in Java


public synchronized void method()

{

_method body_

}

is the equivalent of

public void method()

{

_implicitLock_.lock();

try

{

_method body_

}

---
### Synchronised Keyword

Method

```
public synchronized void deposit(int amount) {
    balance += amount;
}
```

- Locks on the **current object (`this`)**.
- Only one thread at a time can execute _any_ synchronized method on that object.

Synchronised Block

```
public void deposit(int amount) {
    synchronized(this) {
        balance += amount;
    }
}
```

- More **fine-grained control** — only synchronizes the critical section.
    
- Improves performance by reducing the scope of locking.

---
### Static Synchronisation

```
public static synchronized void log(String msg) {
    // ...
}
```

- Locks on the **class object (`ClassName.class`)**, not an instance.
    
- Used when shared data is **static**.

---
### How Synchronisation works?


---

Q. Threads wait for locks in a **blocked state**.

---

**Q. What will be the output of the following code snippet?**

```
class Demo {

    public static synchronized void syncStatic() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

    public synchronized void syncInstance() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        Thread t1 = new Thread(() -> d1.syncStatic(), "A");
        Thread t2 = new Thread(() -> d2.syncInstance(), "B");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Task implements Runnable {

    public synchronized void run() {
        System.out.print(Thread.currentThread().getName() + " ");
        try { Thread.sleep(50); } catch (InterruptedException e) {}
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Task t = new Task();
        Thread t1 = new Thread(t, "1");
        Thread t2 = new Thread(t, "2");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Printer {

    public void print() {
        synchronized(this) {
            System.out.print(Thread.currentThread().getName() + " ");
        }
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Printer p1 = new Printer();
        Printer p2 = new Printer();
        Thread t1 = new Thread(() -> p1.print(), "X");
        Thread t2 = new Thread(() -> p2.print(), "Y");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class MyClass {

    public synchronized static void staticMethod() {
        System.out.print(Thread.currentThread().getName() + " ");
    }

}

public class Test {

    public static void main(String[] args) {
        Runnable r = MyClass::staticMethod;
        Thread t1 = new Thread(r, "A");
        Thread t2 = new Thread(r, "B");
        t1.start(); t2.start();
    }

}
```

---

**Q. What will be the output of the following code snippet?**

```
class Counter {

    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }

}

public class Test {

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -> { 
	        for (int i = 0; i < 1000; i++) counter.increment(); 
		});

        Thread t2 = new Thread(() -> { 
	        for (int i = 0; i < 1000; i++) counter.increment(); 
		});

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println(counter.getCount());

    }

}
```

---
