
You are given an instance of the class `FizzBuzz` that has four functions: `fizz`, `buzz`, `fizzbuzz` and `number`. The same instance of `FizzBuzz` will be passed to four different threads:

- **Thread A:** calls `fizz()` that should output the word `"fizz"`.
- **Thread B:** calls `buzz()` that should output the word `"buzz"`.
- **Thread C:** calls `fizzbuzz()` that should output the word `"fizzbuzz"`.
- **Thread D:** calls `number()` that should only output the integers.

```
class FizzBuzz {

	private int n; // represents the length of sequence to be printed

	public FizzBuzz(int n) {
		this.n = n; 
	}

	public void fizz(Runnable printFizz) throws InterruptedException {
		// printFizz.run() outputs "fizz".
	}

	public void buzz(Runnable printBuzz) throws InterruptedException {
		// printBuzz.run() outputs "buzz".
	}

	
	public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
		// printFizzBuzz.run() outputs "fizzbuzz".
	}

	public void number(IntConsumer printNumber) throws InterruptedException {
		// printNumber.accept(x) outputs "x", where x is an integer.
	}

}
```

Modify the given class to output the series `[1, 2, "fizz", 4, "buzz", ...]` where the `ith` token (`1-indexed`) of the series is:

- `"fizzbuzz"` if `i` is divisible by `3` and `5`,
- `"fizz"` if `i` is divisible by `3` and not `5`,
- `"buzz"` if `i` is divisible by `5` and not `3`, or
- `i` if `i` is not divisible by `3` or `5`.

---
### Metadata

**Link:** [Leetcode 1195](https://leetcode.com/problems/fizz-buzz-multithreaded/?envType=problem-list-v2&envId=concurrency)

**Difficulty:** #Medium

**Recently Asked in Companies:**

---
### General Observations

We need to **print numbers from `1` to `n`**, but using **four separate threads**, each responsible for printing a specific type of output based on the classic FizzBuzz rules.

```
Example 1:

Input: n = 15

Output:[ 1, 2, "fizz", 4, "buzz", "fizz", 7, 8, "fizz", "buzz", 11, "fizz", 13, 14, "fizzbuzz"]

Example 2:

Input: n = 5

Output: [ 1, 2, "fizz", 4, "buzz"]
```

---
### Intuition

The threads must **coordinate with each other** so that only one of them prints for a given number. For example, if the current number is `15`, only the `fizzbuzz` thread should print, and the other threads should do **nothing** and wait.

---
### Approach 1: Using ReentrantLock + Conditions

```
private final int n;
private int current = 1;
private final Lock lock = new ReentrantLock();
private final Condition condition = lock.newCondition();
```

```
public void fizz(Runnable printFizz) throws InterruptedException {
    while (true) {
        lock.lock();
        try {
            while (current <= n && !(current % 3 == 0 && current % 5 != 0)) {
                condition.await();
            }
            if (current > n) break;
            printFizz.run();
            current++;
            condition.signalAll(); // wake up others
        } finally {
            lock.unlock();
        }
    }
}
```

```
public void buzz(Runnable printBuzz) throws InterruptedException {
    while (true) {
        lock.lock();
        try {
            while (current <= n && !(current % 5 == 0 && current % 3 != 0)) {
                condition.await();
            }
            if (current > n) break;
            printBuzz.run();
            current++;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

```
public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
    while (true) {
        lock.lock();
        try {
            while (current <= n && !(current % 3 == 0 && current % 5 == 0)) {
                condition.await();
            }
            if (current > n) break;
            printFizzBuzz.run();
            current++;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

```
public void number(IntConsumer printNumber) throws InterruptedException {
    while (true) {
        lock.lock();
        try {
            while (current <= n && (current % 3 == 0 || current % 5 == 0)) {
                condition.await();
            }
            if (current > n) break;
            printNumber.accept(current);
            current++;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

---
### Key Observation

Only the **number thread** knows the current number. It checks the number and **signals** the correct thread (`fizz`, `buzz`, `fizzbuzz`, or itself) to do the printing. All other threads **wait** until they are signalled.

---
### Approach 2: Using Semaphore





---