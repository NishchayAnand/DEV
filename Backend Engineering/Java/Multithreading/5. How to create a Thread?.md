
Java provides built-in support for multithreading via the `java.lang.Thread` class and the `Runnable` interface. You can launch a separate thread of execution (with its own call stack) by creating a new `Thread` object.

---
### Extending the Thread class

```
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // starts a new thread
    }
}
```

---
### Implementing the Runnable Interface

```
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
```


Sample Code:

```
Thread  t = new Thread();
t.start();
```

The thread `t` defined above would actually do nothing. It "dies" virtually the instant it's born. We need the code that you want to have run by a separate thread passed in as the constructor argument to `Thread()`.

A Thread object needs a job. A job that the thread will run when the thread is started. A thread's jobs can be defined in any class that implements the `Runnable` interface.

When you pass a `Runnable` to a `Thread` constructor, you're really just giving the `Thread` a way to get to a `run()` method (define the code that we want the thread to execute).

Sample Code:

```
Runnable r = new MyThreadJob();
Thread t = new Thread(r);
t.start();
```

Here, `MyThreadJob` is the class that implements the Runnable interface (defines its `run()` method which ). `t.start()` actually starts a new thread, putting the `Runnable` object's `run()` method on the bottom of the new thread's stack.

> **NOTE:** Runnable is the job a thread is supposed to run.

---
