
The `useEffect` hook allows you to run code (`effects`) **after the component renders**.

```
useEffect(callback, dependencies?)
```

The first argument to `useEffect` is a `callback` function where you **perform your side effect**. This function can **return another function**, which will be **used for cleanup.**

The second argument is an optional array of dependencies. The effect runs whenever one of the dependencies changes. <strong><span style="color: red; background: #FFF1E8">If you omit the array, the effect runs after every render. If you provide an empty array, the effect runs only once.</span></strong>

> **NOTE:** The `useEffect` hook is executed **only in the browser**, **after the component has been painted on the screen** (i.e., in the **commit phase**).

---

The `useEffect` hook effectively combines the `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` lifecycle methods.

```
componentDidMount() { ... }
useEffect(() => { ... }, [])

componentWillUnmount() { ... }
useEffect(() => { return () => { ... } }, [])

componentDidUpdate() { ... }
useEffect(() => { ... })
```

---

**Q. What is the difference between `useEffect` and event handlers?**

<strong><span style="color: red">Effects describe side effects caused by rendering, not from user-triggered events.</span></strong>

For example, sending a message in the chat is an event because it is directly caused by the user clicking a specific button. However, setting up a server connection is an Effect because it should happen no matter which interaction caused the component to appear.

```
import { useState, useEffect } from 'react';  

import { createConnection } from './chat.js';  

function ChatRoom({ roomId }) {

	const [serverUrl, setServerUrl] = useState('https://localhost:1234');  

	useEffect(() => {  
		const connection = createConnection(serverUrl, roomId);  
		connection.connect();  
		return () => {  
			connection.disconnect();  
		};  
	}, [serverUrl, roomId]);  

	// ...  

}
```

---

Q. **When does `useEffect` run?**

Effects run at the end of a commit after the screen updates. This is a good time to synchronise your React components with **external systems** like APIs or third-party libraries. 

---

**Q. Implement a custom React hook similar to `useEffect`, but with one key difference: it should skip running the effect on the initial render and only run on subsequent updates.**

We need to implement a custom hook: `useUpdateEffect(callback, dependencies)` that only triggers `callback` function when any of the dependencies update.

```
import {useEffect, useRef} from 'react';

function useUpdateEffect(callback, dependencies = []) {
	const isFirstRender = useRef(true);

	useEffect(() => {
		if(isFirstRender.current) {
			isFirstRender.current = false;
			return;
		}
		return callback();
	}, dependencies);
}
```

---







