
Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the **largest subarray sum is minimised**. Return the minimised largest sum of the split.

**Sample Input:** `nums = [7,2,5,10,8], k = 2`; **Output:** `18`

**Explanation:** There are four ways to split nums into two subarrays:

```
Possible splits into 2 subarrays:

1. [7].       ->  7 [2,5,10,8] -> 25 : max = 25
2. [7,2].     ->  9 [5,10,8].  -> 23 : max = 23
3. [7,2,5].   -> 14 [10,8].    -> 18 : max = 18 (minimum largest sum)
4. [7,2,5,10] -> 24 [8].       ->  8 : max =  8
```

The best way is to split it into `[7,2,5]` and `[10,8]`, where the largest sum among the two subarrays is only `18`.

---
### General Observations

- Should we split the array into **exactly `k` subarrays**, or **at most `k`**?
- **Exactly `k` non-empty subarrays.**

- Can `k` be greater than the number of elements? 
- **`1 <= k <= min(50, nums.length)`** <strong><span style="color: red; background: #FFF1E8">(IMPORTANT)</span></strong>

---
### Recursive Approach - Brute Force

Use recursion to try placing splits at every possible position.

**Hypothesis** 

`F(nums, n, k)` returns the **minimum possible value of the maximum subarray sum** when you **split the first n elements** of the array = `nums[0...n-1]` into **k contiguous subarrays**.

> **NOTE:** If you want to split n elements into k parts, you need **at least k elements**, therefore, k will always be less than or equal to n.

**Recursive Steps**

```
- result = ∞;
- for i = [n-1, k-1, i-1]: try all valid split points
	- right = sum(nums[i...n-1]); // can be computed as suffix sum in O(1)
	- left = F(nums, i, k-1); // recursively solve for the left part
	- maxSum = max(left, right);
	- result = min( result, maxSum );
- result;
```

**Base Conditions**

```
- if k == 1, no split required: return sum(nums[0...n-1]);
```

**Space Complexity** 

The call stack will hold at most `k` recursive function calls simultaneously. Hence, overall space complexity = `O(k)`.

**Time Complexity** 

There are `O(k)` levels of recursion. At each level, we’re trying all split points `i` from `n-1` down to `k-1` (`n-k+1 ~ n`) to partition the subarray under-consideration into 2 halves.  This loosely amounts to `O(2ⁿ)` combinations. 

 Hence, overall time complexity = `O(k × 2ⁿ)`. 

---
### Memoized Recursive Approach

Each unique combination of `(n, k)` defines a **subproblem**. The same `(n, k)` combinations can appear **again and again** in different recursive paths.

We can use a cache, e.g., a 2D array of dimensions: `n × k`  to store the results of previously computed subproblems.

**Increased Space Complexity**

The memoized 2D cache will store `n * k` values. The call stack will hold at most `k` recursive function calls simultaneously. Hence, overall space complexity = `O(n * k)`.

**Reduced Time Complexity**

We are computing `n * k` unique subproblems. For each subproblem, we try all valid split points `i` from `k-1` to `n-1`, so up to `n` splits. Hence, overall time complexity = `O(n² × k)`.

---
### DP Approach

---
### Binary Search Approach - Most Optimised

**Key Observations:** Considering `k` can only be in the range: `[1, n]`, the <strong><span style="color: red; background: #FFF1E8">minimised largest subarray sum</span></strong> will definitely lie somewhere in the range `[max(nums) when k = 1, sum(nums) when k = n]`.

**Intuition:** The <strong><span style="color: red; background: #FFF1E8">minimised largest subarray sum</span></strong> is be the smallest integer in the range: `[max(nums), sum(nums)]` such that <span style="color: green;">we can divide the array into k subarrays where every individual subarray sum &lt;= maxSum</span>.

Run binary search in the range: `[max(nums), sum(nums)]` to find ...

**Algorithm**

```
```

**Space Complexity**

**Time Complexity**

---





