
Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the **largest sum of any subarray is minimised**. Return the minimised largest sum of the split.

**Sample Input:** `nums = [7,2,5,10,8], k = 2`; **Output:** `18`

**Explanation:** There are four ways to split nums into two subarrays:

```
Possible splits into 2 subarrays:

1. [7].       ->  7 [2,5,10,8] -> 25 : max = 25
2. [7,2].     ->  9 [5,10,8].  -> 23 : max = 23
3. [7,2,5].   -> 14 [10,8].    -> 18 : max = 18 (minimum largest sum)
4. [7,2,5,10] -> 24 [8].       ->  8 : max =  8
```

The best way is to split it into `[7,2,5]` and `[10,8]`, where the largest sum among the two subarrays is only `18`.

---
### General Observations

- Should we split the array into **exactly `k` subarrays**, or **at most `k`**?
- **Exactly `k` non-empty subarrays.**

- Can `k` be greater than the number of elements? 
- **`1 <= k <= min(50, nums.length)`** <strong><span style="color: red; background: #FFF1E8">(IMPORTANT)</span></strong>

---
### Recursive Approach - Brute Force

Use recursion to try placing splits at every possible position.

**Hypothesis:** `F(nums, n, k)` returns the **minimum possible value of the maximum subarray sum** when you **split the first n elements** of the array = `nums[0...n-1]` into **k contiguous subarrays**.

> **NOTE:** If you want to split n elements into k parts, you need **at least k elements**, therefore, k will always be less than or equal to n.

**Recursive Steps:**

```
- result = Infinity;
- start loop from i = n-1, decrement by 1 till i = k-1: // refer NOTE above
	- right = sum(nums[i...n-1]); // can be computed using prefix sum logic
	- left = F(nums, i, k-1);
	- result = min( result, max(left, right) );
- result;
```

**Base Conditions:**

```
- if k == 1, no split required: return sum(nums[0...n-1]);
```

**Time Complexity:** At each split, we are dividing the subarray under-consideration in two parts. O(k × 2ⁿ) <strong><span style="color: red; background: #FFF1E8">????</span></strong>

**Space Complexity:** O(k).

---
### Memoized Recursive Approach

---
### DP Approach

---
### Binary Search Approach - Most Optimised




---





