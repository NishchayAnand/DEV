
Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the **largest sum of any subarray is minimised**. Return the minimised largest sum of the split.

**Sample Input:** `nums = [7,2,5,10,8], k = 2`; **Output:** `18`

**Explanation:** There are four ways to split nums into two subarrays:

```
Possible splits into 2 subarrays:

1. [7].        ->7 [2,5,10,8] ->25 : max = 25
2. [7,2].      ->9 [5,10,8].  ->23 : max = 23
3. [7,2,5].   ->14 [10,8].    ->18 : max = 18 (minimum largest sum)
4. [7,2,5,10] ->24 [8].        ->8 : max =  8
```

The best way is to split it into `[7,2,5]` and `[10,8]`, where the largest sum among the two subarrays is only `18`.

---
### General Observations

- Should we split the array into **exactly `k` subarrays**, or **at most `k`**?
- **Exactly `k` non-empty subarrays.**

- Can `k` be greater than the number of elements? 
- **`1 <= k <= min(50, nums.length)`** <strong><span style="color: red; background: #FFF1E8">(IMPORTANT)</span></strong>

---
### Recursive Approach - Brute Force

Use recursion to try placing splits at every possible position.

**Algorithm:**

```
Hypothesis: F(nums, n, k) returns the minimum possible value of the maximum subarray sum when you split the first n elements of the array = nums[0...n-1] into k contiguous subarrays.

Recursive Steps:
	- 

```

**Time Complexity:**

**Space Complexity:**


---
### Binary Search Approach - Most Optimised


---





