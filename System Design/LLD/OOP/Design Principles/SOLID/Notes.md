# Understanding SOLID

SOLID is an acronym for five key principles in object-oriented design:

- **Single Responsibility Principle:** A module should have one, and only one, reason to change.

- **Open-Closed Principle:** A software artifact should be open for extension but closed for modification.

- **Liskov Substitution Principle**
- **Interface Segregation Principle**
- **Dependency Inversion Principle**

## Use Case

**A module should have one, and only one, reason to change.** Software systems are changed to satisfy users and stakeholders. Those **users and stakeholders** are the **"reason to change"** that the principle is talking about.

There will likely be more than one user or stakeholder who wants the system changed in the same way. Instead, we're really referring to a group of one or more people who require that change. We'll refer to that group as an `actor`.

```
Employee (class)
  + calculatePay() -> used by the accounting department, which reports to the CFO.
  + reportHours()  -> used by the human resources department, which reports to the COO.
  + save()         -> used by the database administrators (DBAs), who reports to the CTO.
```

By putting the source code for the above three methods into a single Employee class, the developers have coupled each of these actors to the others. This coupling can cause the actions of the CFO's team to affect something that the COO's team depend on.

For example, suppose that the `calculatePay()` and `reportHours()` method share a common algorithm for calculating non-overtime hours: `regularHours()`. Now suppose that the CFO's team decides that the way non-overtime hours are calculated needs to be tweaked. In contrast, the COO's team does not want that particular tweat because they use non-overtime hours for a different purpose.

A developer is tasked to make the change, and sees the convenient `regularHours()` function called by the `calculatePay()` method. Unfortunately, that developer does not notice that the function is also used by the `reportHours()` function.

The developer makes the required changes and carefully tests it. The CFO's team validates that the new function works as desired, and the system is deployed.

Of course, the COO's team doesn't know that this is happening. The HR personnel continue to use the reports generated by the `reportHours()` function, but now they contain incorrect numbers. Eventually the problem is discovered, and the COO is livid because the bad data has cost his budget millions of dollars.

**SRP says to separate the code that different actors depend on.**

The most obvious way to solve the problem is to **separate the data from the functions (separation of concerns principle).** Create three classes that share access to `EmployeeData`, which is a simple data structure with no methods.

```
interface HoursCalculator {
    int calculateRegularHours(Employee employee);
}

class DefaultHoursCalculator implements HoursCalculator {
    @Override
    public int calculateRegularHours(Employee employee) {
        // Default implementation of calculating regular hours
        return employee.getRegularHours();
    }
}

class Employee {
    private int regularHours;
    // ... other employee attributes

    public int getRegularHours() {
        return regularHours;
    }
    // ... other employee methods
}

class PayrollCalculator {
    private final HoursCalculator hoursCalculator;

    public PayrollCalculator(HoursCalculator hoursCalculator) {
        this.hoursCalculator = hoursCalculator;
    }

    public double calculatePay(Employee employee) {
        int regularHours = hoursCalculator.calculateRegularHours(employee);
        // ... calculate pay based on regular hours
        return calculatedPay;
    }
}

class TimeTracker {
    private final HoursCalculator hoursCalculator;

    public TimeTracker(HoursCalculator hoursCalculator) {
        this.hoursCalculator = hoursCalculator;
    }

    public void reportHours(Employee employee) {
        int regularHours = hoursCalculator.calculateRegularHours(employee);
        // ... report hours based on regular hours
    }
}

class EmployeeDataRepository {
    // Methods for saving and retrieving employee data
}
```

The downside of this solution is that developers (clients) now have three classes that they have to instantiate and track. A common solution to this dilemma is to use **FACADE PATTERN**.

```
public class EmployeeFacade {
    private final PayrollCalculator payrollCalculator;
    private final TimeTracker timeTracker;
    private final EmployeeDataRepository employeeDataRepository;

    public EmployeeFacade() {
        // Dependency injection or creation of components here
        payrollCalculator = new PayrollCalculator(new DefaultHoursCalculator());
        timeTracker = new TimeTracker(new DefaultHoursCalculator());
        employeeDataRepository = new EmployeeDataRepository();
    }

    public double calculatePay(Employee employee) {
        return payrollCalculator.calculatePay(employee);
    }

    public void reportHours(Employee employee) {
        timeTracker.reportHours(employee);
    }

    public void saveEmployee(Employee employee) {
        employeeDataRepository.saveEmployee(employee);
    }
}
```
